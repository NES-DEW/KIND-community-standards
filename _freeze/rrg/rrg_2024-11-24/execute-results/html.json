{
  "hash": "e699e4804a8c7122175096c86cd12ec6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R reading group notes\"\ndate: \"2024-11-21\"\nexecute: \n  echo: true\noutput: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n  \nThis was about the [vectors chapter in Advanced R (2nd ed)](https://adv-r.hadley.nz/vectors-chap.html). It's mainly about how vectors and lists work.\n\n## Types of vector\n\nThere are a few odd extras, but nearly all vectors in the wild can be taxonomised like this:\n\n* atomic vectors (same type)\n  * numeric\n    * integer\n      * `1234L`, `1e4L`, or `0xcafeL`\n    * double\n      * decimal (`0.1234`), scientific (`1.23e4`), hex (`0xcafe`), `Inf`, `-Inf`, and `NaN`\n  * logical\n  * character\n* lists (potentially mixed type)\n* `NULL` (a 0-length vector)\n\n## Scalars and vectors\n\n* scalars = individual values = length-one vectors\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"steve\" # scalar\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"steve\"\n```\n\n\n:::\n\n```{.r .cell-code}\n9 # scalar\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n* make longer vectors with `c()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(T, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nflat <- c(c(\"nested\", \"vectors\"), c(\"get\", \"flattened\"))\nflat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nested\"    \"vectors\"   \"get\"       \"flattened\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(flat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n+ understanding lists vs vectors as largely about hierarchical structure. Vectors are flat, while lists are hierchical:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(\"this\"), c(\"gets completely\"), \"flattened\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this\"            \"gets completely\" \"flattened\"      \n```\n\n\n:::\n\n```{.r .cell-code}\nlist(c(\"this\"), list(\"gets\", \"not\", \"at all\"), \"flattened\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"this\"\n\n[[2]]\n[[2]][[1]]\n[1] \"gets\"\n\n[[2]][[2]]\n[1] \"not\"\n\n[[2]][[3]]\n[1] \"at all\"\n\n\n[[3]]\n[1] \"flattened\"\n```\n\n\n:::\n:::\n\n\n\n\n* we then did a lot of experimenting with empty lists and vectors \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"d\", 1) == c(\"d\", \"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlist(\"c\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"c\"\n\n[[2]]\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n## create an empty vector\nvector(\"character\", 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\n## create an empty list\nvector(\"list\", 0) # the weird one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\nunlist(vector(\"list\", 0)) # because NULL is effectively a 0-length vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(unlist(list()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n## Testing for vectors\n\nThis is a big issue because many R functions will coerce, and it can cause serious trouble. There's a bit of discussion about the ordering, where character is basically the ground state/most basic, then double, then integer, then logical. So logical only gets made from logical inputs, integer from logical or integer, double from double, or integer, or logical, and character from anything.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nis.logical(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.integer(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(\"one\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nNA_character_ # if you really want to ruin your life\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# character → double → integer → logical\n\nc(T, T) |> typeof()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(T, F) |> typeof()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(T, 1L) |> typeof()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(T, 1) |> typeof()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(T, NA_character_) |> typeof()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(T, 1, NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  1 NA\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(NA_character_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NA\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NA\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### The danger zone\n\nThis area is rich in false friends - functions with plausible-sounding names that do something unusual and not entirely what you might expect from their name:\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntesty1 <- c(1,2,3)\ntesty2 <- list(one = 1, two = 2, three = 3)\ntesty3 <- expression(x = 1)\n\nis.vector(testy1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(testy2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(testy3) # includes lists and expressions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(testy1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(testy2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.atomic(testy3)# i.e. not recursive\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(testy1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(testy2) # even though everything is numeric, this list doesn't count as numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(testy2, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  one   two three \n TRUE  TRUE  TRUE \n```\n\n\n:::\n:::\n\n\n\n\n## Attributes\nVectors can have attributes - like names. Most attributes are pretty fragile, and get removed very easily:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntesty4 <- c(one = 1, two = 2, three = 3)\ntypeof(testy4) # definitely not a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(testy4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"one\"   \"two\"   \"three\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(testy4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"one\"   \"two\"   \"three\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(testy4, \"names\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"one\"   \"two\"   \"three\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(testy4, \"supernames\") <- c(\"one but secret\", \"two but secret\", \"three but secret\")\nattributes(testy4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"one\"   \"two\"   \"three\"\n\n$supernames\n[1] \"one but secret\"   \"two but secret\"   \"three but secret\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(attributes(testy4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ names     : chr [1:3] \"one\" \"two\" \"three\"\n $ supernames: chr [1:3] \"one but secret\" \"two but secret\" \"three but secret\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}