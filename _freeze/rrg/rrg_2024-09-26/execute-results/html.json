{
  "hash": "b41edb7539f39cf6361e59fff0e95386",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R reading group notes\"\ndate: \"2024-09-26\"\nexecute: \n  echo: true\n  output: true\neditor_options: \n  chunk_output_type: console\n---\n\n\nThis was about the [names and values chapter in Advanced R (2nd ed)](https://adv-r.hadley.nz/names-values.html). It's mainly about understanding how objects are named in R, and what the implications are for ordinary R practitioners. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lobstr) # to help understand how objects are structured\nlibrary(dplyr)\nlibrary(microbenchmark)\n```\n:::\n\n\nThe first point is about names. We usually think about assignment as making an object called `x`. But it's definitely better to think about these separately - first creating an object and then binding it to a name. That means that names have objects, rather than objects having names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3) # create an object\nobj_addr(x) # location in memory\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c74139378\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x # bind an additional name to the object\nobj_addr(x) == obj_addr(y) # it's just one object with two names\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThis applies to objects in general, including function definitions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_addr(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c6f61eab0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsteve <- mean\nobj_addr(steve)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c6f61eab0\"\n```\n\n\n:::\n:::\n\n\nWe only create a new object when we modify one of the names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[3] <- 9\nobj_addr(x) == obj_addr(y) # different objects now\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThere are a couple of important exceptions to this general principle. First, lists have an extra step, in that they refer to references, rather than to objects directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(1, 2, 3)\nl2 <- l1\n\nobj_addr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c75262678\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c75262678\"\n```\n\n\n:::\n\n```{.r .cell-code}\nl2[[3]] <- 99\n\nobj_addr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c75262678\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x26c75462e98\"\n```\n\n\n:::\n\n```{.r .cell-code}\nref(l1, l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x26c75262678] <list> \n├─[2:0x26c74f7e938] <dbl> \n├─[3:0x26c74f7e900] <dbl> \n└─[4:0x26c74f7e8c8] <dbl> \n \n█ [5:0x26c75462e98] <list> \n├─[2:0x26c74f7e938] \n├─[3:0x26c74f7e900] \n└─[6:0x26c74f7e778] <dbl> \n```\n\n\n:::\n:::\n\n\nAs tibbles (and other tabular data structures in R) are effectively lists, this is an explaination as to why row-wise operations are so slow compared to operations on columns. As tibbles are are lists of columns, updating a column just makes a new reference. Changing a row, on the other hand, makes a whole new set of objects and references:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmt_changed_col <- mtcars\nmt_changed_col$hp <- mtcars$hp*9\n\nmt_changed_row <- mtcars\nmt_changed_row[1,] <- mt_changed_row[1,] * 9\n\nref(mtcars, mt_changed_col, mt_changed_row)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x26c741467c8] <df[,11]> \n├─mpg = [2:0x26c703532c0] <dbl> \n├─cyl = [3:0x26c70353ea0] <dbl> \n├─disp = [4:0x26c703545c0] <dbl> \n├─hp = [5:0x26c703533f0] <dbl> \n├─drat = [6:0x26c70354820] <dbl> \n├─wt = [7:0x26c70355400] <dbl> \n├─qsec = [8:0x26c70355530] <dbl> \n├─vs = [9:0x26c70354bb0] <dbl> \n├─am = [10:0x26c70353060] <dbl> \n├─gear = [11:0x26c70353650] <dbl> \n└─carb = [12:0x26c70353780] <dbl> \n \n█ [13:0x26c74146d48] <df[,11]> \n├─mpg = [2:0x26c703532c0] \n├─cyl = [3:0x26c70353ea0] \n├─disp = [4:0x26c703545c0] \n├─hp = [14:0x26c70353fd0] <dbl> \n├─drat = [6:0x26c70354820] \n├─wt = [7:0x26c70355400] \n├─qsec = [8:0x26c70355530] \n├─vs = [9:0x26c70354bb0] \n├─am = [10:0x26c70353060] \n├─gear = [11:0x26c70353650] \n└─carb = [12:0x26c70353780] \n \n█ [15:0x26c72e7d748] <df[,11]> \n├─mpg = [16:0x26c70354100] <dbl> \n├─cyl = [17:0x26c70354230] <dbl> \n├─disp = [18:0x26c70354360] <dbl> \n├─hp = [19:0x26c70354950] <dbl> \n├─drat = [20:0x26c703546f0] <dbl> \n├─wt = [21:0x26c70356700] <dbl> \n├─qsec = [22:0x26c70355eb0] <dbl> \n├─vs = [23:0x26c70355fe0] <dbl> \n├─am = [24:0x26c6eed38b0] <dbl> \n├─gear = [25:0x26c6eed4360] <dbl> \n└─carb = [26:0x26c6eed3780] <dbl> \n```\n\n\n:::\n\n```{.r .cell-code}\ncol_row <- microbenchmark(\n  {mt_changed_col <- mtcars\n  mt_changed_col[\"hp\"] <- mtcars[\"hp\"]*9},\n  \n  {mt_changed_row <- mtcars\n  mt_changed_row[1,] <- mt_changed_row[1,] * 9}\n)\n\ncol_row |>\n  mutate(expr = case_when(stringr::str_detect(expr, \"col\") ~ \"by col\",\n                          TRUE ~ \"by row\"))  |>\n  group_by(expr) |>\n  summarise(`mean time (μs)` = mean(time)/1000) |>\n  knitr::kable() # about 4x faster to change the col than the row\n```\n\n::: {.cell-output-display}\n\n\n|expr   | mean time (μs)|\n|:------|--------------:|\n|by col |        472.550|\n|by row |       1393.922|\n\n\n:::\n\n```{.r .cell-code}\nggplot2::autoplot(col_row)\n```\n\n::: {.cell-output-display}\n![](rrg_2024-09-26_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWe also looked briefly at alternative representation. The range operator is the best example of highly compact representations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(1:1000000) # approx size?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(1:2) == obj_size(1:1000000) # the range operator only stores the first and last values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(seq(1, 1000000)) # seq will use the same alternative representation...\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(seq(1, 1000000, 1.0)) # unless you ask it to make a sequence with non-1L steps \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n:::\n\n\n`object.size` has lots of interesting implications for lists as it only describes the size of the references, rather than the underlying objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(rnorm(1e6)) # 8 mb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nmill <- obj_size(rnorm(1e6)) \n\nobj_size(list(rnorm(1e6), rnorm(1e6), rnorm(1e6)))#??\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n24.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(list(mill, mill, mill))#??\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n368 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(tibble(a = mill, \n                b = mill,\n                c = mill))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.21 kB\n```\n\n\n:::\n:::\n\n\nAll strings are held in a common area of memory called the common string pool. This gives rise to a lot of interesting size consequence for vectors with shared strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1 <- c(\"the\", \"cat\", \"sat\", \"mat\")\ns2 <- c(\"the\", \"the\", \"the\", \"the\")\n\nobj_size(s1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n304 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(s2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n136 B\n```\n\n\n:::\n\n```{.r .cell-code}\nref(s1, character = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x26c77e629b8] <chr> \n├─[2:0x26c6f69dd48] <string: \"the\"> \n├─[3:0x26c67a59378] <string: \"cat\"> \n├─[4:0x26c749bebe0] <string: \"sat\"> \n└─[5:0x26c6e575880] <string: \"mat\"> \n```\n\n\n:::\n\n```{.r .cell-code}\nref(s2, character = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x26c77e61158] <chr> \n├─[2:0x26c6f69dd48] <string: \"the\"> \n├─[2:0x26c6f69dd48] \n├─[2:0x26c6f69dd48] \n└─[2:0x26c6f69dd48] \n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(c(1,2,3,4)) # numeric vectors don't behave in the same way\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n80 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(c(4,4,4,4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n80 B\n```\n\n\n:::\n:::\n",
    "supporting": [
      "rrg_2024-09-26_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}