{
  "hash": "b41edb7539f39cf6361e59fff0e95386",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R reading group notes\"\ndate: \"2024-09-26\"\nexecute: \n  echo: true\n  output: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nThis was about the [names and values chapter in Advanced R (2nd ed)](https://adv-r.hadley.nz/names-values.html). It's mainly about understanding how objects are named in R, and what the implications are for ordinary R practitioners. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lobstr) # to help understand how objects are structured\nlibrary(dplyr)\nlibrary(microbenchmark)\n```\n:::\n\n\n\n\nThe first point is about names. We usually think about assignment as making an object called `x`. But it's definitely better to think about these separately - first creating an object and then binding it to a name. That means that names have objects, rather than objects having names.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3) # create an object\nobj_addr(x) # location in memory\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a734e58968\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x # bind an additional name to the object\nobj_addr(x) == obj_addr(y) # it's just one object with two names\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThis applies to objects in general, including function definitions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_addr(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a7313980d0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsteve <- mean\nobj_addr(steve)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a7313980d0\"\n```\n\n\n:::\n:::\n\n\n\n\nWe only create a new object when we modify one of the names:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[3] <- 9\nobj_addr(x) == obj_addr(y) # different objects now\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nThere are a couple of important exceptions to this general principle. First, lists have an extra step, in that they refer to references, rather than to objects directly:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(1, 2, 3)\nl2 <- l1\n\nobj_addr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a734e69248\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a734e69248\"\n```\n\n\n:::\n\n```{.r .cell-code}\nl2[[3]] <- 99\n\nobj_addr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a734e69248\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x1a73602faa8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nref(l1, l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x1a734e69248] <list> \n├─[2:0x1a733dadac0] <dbl> \n├─[3:0x1a733dada88] <dbl> \n└─[4:0x1a733dada50] <dbl> \n \n█ [5:0x1a73602faa8] <list> \n├─[2:0x1a733dadac0] \n├─[3:0x1a733dada88] \n└─[6:0x1a733dad4d8] <dbl> \n```\n\n\n:::\n:::\n\n\n\n\nAs tibbles (and other tabular data structures in R) are effectively lists, this is an explaination as to why row-wise operations are so slow compared to operations on columns. As tibbles are are lists of columns, updating a column just makes a new reference. Changing a row, on the other hand, makes a whole new set of objects and references:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmt_changed_col <- mtcars\nmt_changed_col$hp <- mtcars$hp*9\n\nmt_changed_row <- mtcars\nmt_changed_row[1,] <- mt_changed_row[1,] * 9\n\nref(mtcars, mt_changed_col, mt_changed_row)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x1a734e48b38] <df[,11]> \n├─mpg = [2:0x1a734ffa070] <dbl> \n├─cyl = [3:0x1a734ff9e10] <dbl> \n├─disp = [4:0x1a734ff9100] <dbl> \n├─hp = [5:0x1a734ffa2d0] <dbl> \n├─drat = [6:0x1a734ff9f40] <dbl> \n├─wt = [7:0x1a734ff9a80] <dbl> \n├─qsec = [8:0x1a734ff9ce0] <dbl> \n├─vs = [9:0x1a734ffa400] <dbl> \n├─am = [10:0x1a734ff89e0] <dbl> \n├─gear = [11:0x1a734ffa530] <dbl> \n└─carb = [12:0x1a734ff82c0] <dbl> \n \n█ [13:0x1a734e47748] <df[,11]> \n├─mpg = [2:0x1a734ffa070] \n├─cyl = [3:0x1a734ff9e10] \n├─disp = [4:0x1a734ff9100] \n├─hp = [14:0x1a734ff83f0] <dbl> \n├─drat = [6:0x1a734ff9f40] \n├─wt = [7:0x1a734ff9a80] \n├─qsec = [8:0x1a734ff9ce0] \n├─vs = [9:0x1a734ffa400] \n├─am = [10:0x1a734ff89e0] \n├─gear = [11:0x1a734ffa530] \n└─carb = [12:0x1a734ff82c0] \n \n█ [15:0x1a734e663a8] <df[,11]> \n├─mpg = [16:0x1a734ff8520] <dbl> \n├─cyl = [17:0x1a734ff88b0] <dbl> \n├─disp = [18:0x1a734ff8d70] <dbl> \n├─hp = [19:0x1a734ff9360] <dbl> \n├─drat = [20:0x1a734ff8ea0] <dbl> \n├─wt = [21:0x1a734ff8780] <dbl> \n├─qsec = [22:0x1a734ff8b10] <dbl> \n├─vs = [23:0x1a734ff9490] <dbl> \n├─am = [24:0x1a734ff95c0] <dbl> \n├─gear = [25:0x1a734ff96f0] <dbl> \n└─carb = [26:0x1a734ff9820] <dbl> \n```\n\n\n:::\n\n```{.r .cell-code}\ncol_row <- microbenchmark(\n  {mt_changed_col <- mtcars\n  mt_changed_col[\"hp\"] <- mtcars[\"hp\"]*9},\n  \n  {mt_changed_row <- mtcars\n  mt_changed_row[1,] <- mt_changed_row[1,] * 9}\n)\n\ncol_row |>\n  mutate(expr = case_when(stringr::str_detect(expr, \"col\") ~ \"by col\",\n                          TRUE ~ \"by row\"))  |>\n  group_by(expr) |>\n  summarise(`mean time (μs)` = mean(time)/1000) |>\n  knitr::kable() # about 4x faster to change the col than the row\n```\n\n::: {.cell-output-display}\n\n\n|expr   | mean time (μs)|\n|:------|--------------:|\n|by col |        306.900|\n|by row |       1047.938|\n\n\n:::\n\n```{.r .cell-code}\nggplot2::autoplot(col_row)\n```\n\n::: {.cell-output-display}\n![](rrg_2024-09-26_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\nWe also looked briefly at alternative representation. The range operator is the best example of highly compact representations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(1:1000000) # approx size?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(1:2) == obj_size(1:1000000) # the range operator only stores the first and last values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(seq(1, 1000000)) # seq will use the same alternative representation...\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(seq(1, 1000000, 1.0)) # unless you ask it to make a sequence with non-1L steps \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n:::\n\n\n\n\n`object.size` has lots of interesting implications for lists as it only describes the size of the references, rather than the underlying objects:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(rnorm(1e6)) # 8 mb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nmill <- obj_size(rnorm(1e6)) \n\nobj_size(list(rnorm(1e6), rnorm(1e6), rnorm(1e6)))#??\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n24.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(list(mill, mill, mill))#??\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n368 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(tibble(a = mill, \n                b = mill,\n                c = mill))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.21 kB\n```\n\n\n:::\n:::\n\n\n\n\nAll strings are held in a common area of memory called the common string pool. This gives rise to a lot of interesting size consequence for vectors with shared strings:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1 <- c(\"the\", \"cat\", \"sat\", \"mat\")\ns2 <- c(\"the\", \"the\", \"the\", \"the\")\n\nobj_size(s1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n304 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(s2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n136 B\n```\n\n\n:::\n\n```{.r .cell-code}\nref(s1, character = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x1a73902fd58] <chr> \n├─[2:0x1a7302a1d48] <string: \"the\"> \n├─[3:0x1a72945a378] <string: \"cat\"> \n├─[4:0x1a734fb0b88] <string: \"sat\"> \n└─[5:0x1a72f182880] <string: \"mat\"> \n```\n\n\n:::\n\n```{.r .cell-code}\nref(s2, character = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n█ [1:0x1a73903cc28] <chr> \n├─[2:0x1a7302a1d48] <string: \"the\"> \n├─[2:0x1a7302a1d48] \n├─[2:0x1a7302a1d48] \n└─[2:0x1a7302a1d48] \n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(c(1,2,3,4)) # numeric vectors don't behave in the same way\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n80 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(c(4,4,4,4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n80 B\n```\n\n\n:::\n:::\n",
    "supporting": [
      "rrg_2024-09-26_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}