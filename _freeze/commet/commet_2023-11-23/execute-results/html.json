{
  "hash": "cd53b413dd58fe519275aa2877c3e252",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Test driven development\"\ndate: 2023-11-21\ncategories: [R, testing, intermediate, excel]\nexecute: \n  output: markup\n  echo: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Intro\n\n-   this session is about test-driven development (TDD)\n-   we'll start with a bit of chat and some polling about testing\n-   then we'll do a bit of explanation to introduce TDD\n-   and most of the session is about showing a simple implementation of TDD in Excel, and a slightly less simple implementation in R\n\n## Testing your work\n\n-   poll: who tests their work at all?\n-   please share in the chat ways that you test your work\n-   poll: who has a formal process for that testing?\n-   please share in the chat a bit on your testing process\n-   poll: who shares that testing process with their colleagues?\n\n## TDD-what?\n\n-   (before all that polling) my guess is that...\n    -   nearly everyone will test their work in some way, but that\n    -   most of that testing will be ad hoc / informal\n    -   and that more formal testing is quite rare\n    -   and I'll guess that no-one has a standard shared testing process in their group\n\n## TDD = test driven development\n\n-   work should go like this:\n    1.  have an idea for a new thing\n    2.  develop something to do that thing\n    3.  test to check that the thing is done\n\n## TDD = test driven development\n\n-   but too often the work goes:\n    1.  have an idea for a new thing\n    2.  develop something to do that thing\n    3.  have an idea for a new thing\n    4.  ...\n\n## TDD = test driven development\n\n-   what if we reversed the usual order?\n    1.  have an idea for a new thing\n    2.  write a test to check that the thing is done\n    3.  develop something to pass that test\n-   this also might make testing more fun, given a pretty loose definition of *fun*\n\n## We don't need fancy tools to do TDD\n\n-   it's perfectly possible in Excel\n-   imagine we're writing a formula to find out something about our data (maybe totaling a column)\n    -   we could take part of our data\n    -   calculate a test value by hand (say, by adding up all the values in our test data)\n    -   then using that test value to check that our formula is returning the right result\n    -   you could even go mad and use conditional formatting etc to check that's happening properly </br>![Simple test suite in Excel](images/clipboard-1423133683.png)</br>   ![Showing test formulas](images/clipboard-2720488193.png)\n\n## Recap\n\n-   decide what to do\n-   write a test to check that thing\n-   develop to pass the test\n\n## R time\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\nlibrary(tibble)\n```\n:::\n\n\n-   in `testthat`, tests are built of expectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpect_equal(2 * 2, 4)\nexpect_identical(1L, 1L)\n```\n:::\n\n\n## Tale of two great expectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Testing that numbers work properly\", {\n  expect_equal(2 * 2, 4, label = \"Multo\")\n  expect_identical(1L, 1L, label = \"Class!\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed ðŸŽ‰\n```\n\n\n:::\n:::\n\n\n## Lots of expectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpect_setequal(1:3, c(1,2,3))\n\nfnarp = tibble(a = c(1, 2, 3))\n\nglarp = tibble(a = c(1, 2, 3))\n  \nexpect_mapequal(fnarp, glarp) # for named objects\n```\n:::\n\n\n## Grouping into tests\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Testing that sets work properly\", {\n  expect_setequal(1:3, c(1,2,3))\n  expect_mapequal(fnarp, glarp)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed ðŸŽŠ\n```\n\n\n:::\n\n```{.r .cell-code}\ntest_that(\"Testing classes\", {\n  expect_that(mtcars, is_a(\"data.frame\"))\n  expect_that(1:5, is_a(\"integer\"))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed ðŸ˜€\n```\n\n\n:::\n:::\n\n\n## Context\n\n-   context = groups of tests\n-   previously important to R testing\n-   now, use files instead\n\n## Test files\n\n1.  put all tests in a file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R/tests.R\n\ntest_that(\"Testing that numbers work properly\", {\n  expect_equal(2 * 2, 4, label = \"Multo\")\n  expect_identical(1L, 1L, label = \"Class!\")\n})\n\ntest_that(\"Testing that sets work properly\", {\n  expect_setequal(1:3, c(1,2,3))\n  expect_mapequal(fnarp, glarp)\n})\n```\n:::\n\n\n2.  run with `testthat::test_file()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntestthat::test_file(\"R/tests.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n```\n\n\n:::\n:::\n\n\n## Bit of live development\n\n-   [Reverse and Invert](https://www.codewars.com/kata/5899e054aa1498da6b0000cc)\n-   \"reverse and invert all integer values\" in a vector\n-   tests first!\n-   granular tests: quick, small and simple\n-   basic code: just pass the test\n-   add test, pass, refactor, repeat\n  - I ended up with something like `as.integer(intToUtf8(rev(utf8ToInt(as.character(n)))))`\n\n\n## \n",
    "supporting": [
      "commet_2023-11-23_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}