{
  "hash": "22dd670fcbfa100004c098bfaf60f84b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joins 1: introduction\"\ndate: 2024-09-02\ncategories: [Joins, beginner, Excel, R, Power Query]\nexecute: \n  output: asis\n  echo: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n## How to think about joins?\n\nA join is a way of merging two datasets. Let's demonstrate with some simple data:\n\n\n\n\n\n```{.r .cell-code}\nlibrary(tibble)\nlibrary(dplyr)\n```\n\n\n```{.r .cell-code}\nx <- tibble(\n  name = c(\"Steve\", \"Emma\", \"Arti\"),\n  tool = c(\"R\", \"Excel\", \"Excel\"),\n  training_sessions = c(4,3,7)\n)\n```\n\n\n|name  |tool  | training_sessions|\n|:-----|:-----|-----------------:|\n|Steve |R     |                 4|\n|Emma  |Excel |                 3|\n|Arti  |Excel |                 7|\n\n\n```{.r .cell-code}\ny <- tibble(\n  name = c(\"Abena\", \"Yuika\", \"Arti\"),\n  tool = c(\"R\", \"Excel\", \"Power BI\"),\n  training_sessions = c(3,5,3)\n)\n```\n\n\n|name  |tool     | training_sessions|\n|:-----|:--------|-----------------:|\n|Abena |R        |                 3|\n|Yuika |Excel    |                 5|\n|Arti  |Power BI |                 3|\n\n\n\n\n## Binding\n\nThe simplest join we could do is to bind the rows from one set onto another:\n\n\n\n\n\n```{.r .cell-code}\nx |>\n  bind_rows(y) |>\n  knitr::kable()\n```\n\n\n\n|name  |tool     | training_sessions|\n|:-----|:--------|-----------------:|\n|Steve |R        |                 4|\n|Emma  |Excel    |                 3|\n|Arti  |Excel    |                 7|\n|Abena |R        |                 3|\n|Yuika |Excel    |                 5|\n|Arti  |Power BI |                 3|\n\n\n\n\nThat just brings all the rows from `y` onto the end of `x`. We could also have just bound the columns together:\n\n\n\n\n\n```{.r .cell-code}\nx |>\n  bind_cols(y) |>\n  knitr::kable()\n```\n\n\n\n|name...1 |tool...2 | training_sessions...3|name...4 |tool...5 | training_sessions...6|\n|:--------|:--------|---------------------:|:--------|:--------|---------------------:|\n|Steve    |R        |                     4|Abena    |R        |                     3|\n|Emma     |Excel    |                     3|Yuika    |Excel    |                     5|\n|Arti     |Excel    |                     7|Arti     |Power BI |                     3|\n\n\n\n\nDoing this in R, we end up with something quite messy: we've gained some new columns (with odd names), and lots of blank values. The reason for this is that Arti has a row in each dataset. Anyone without corresponding rows gets filling in with blanks.\n\nWe could do something very similar by hand in Excel. It's worth noting the `VSTACK` function, which allows you to bring one table into another in Excel. PowerQuery has some great tools for binding data. `Append Queries` allows you to perform row-binding:\n\n![Select Append Queries](images/clipboard-2952836979.png)\n\n![Select datasets to bind together](images/clipboard-3653621168.png)\n\n![New table containing all rows from the original](images/clipboard-1970651010.png)\n\nHowever we bind, the main distinction remains the same. When you bind, the values in your data are irrelevant. Column names will matter - e.g. row binding works when you have identically named columns. But the values themselves don't matter at all.\n\n## Joins proper\n\nUnlike binding, though, a join will pay attention to the values found in our data. For example, we could do a left-join:\n\n![A left-join](images/left.png)\n\nThis would retain any data from our x dataset, but also bring in any matching data from y.So let's now left-join `y` onto x using the `name` column:\n\n\n\n\n\n```{.r .cell-code}\nx |>\n  left_join(y, by = \"name\") |>\n  knitr::kable()\n```\n\n\n\n|name  |tool.x | training_sessions.x|tool.y   | training_sessions.y|\n|:-----|:------|-------------------:|:--------|-------------------:|\n|Steve |R      |                   4|NA       |                  NA|\n|Emma  |Excel  |                   3|NA       |                  NA|\n|Arti  |Excel  |                   7|Power BI |                   3|\n\n\n\n\nWe'd get entirely different results if we joined on the `tool` column:\n\n\n\n\n\n```{.r .cell-code}\nx |>\n  left_join(y, by = \"tool\") |>\n  knitr::kable()\n```\n\n\n\n|name.x |tool  | training_sessions.x|name.y | training_sessions.y|\n|:------|:-----|-------------------:|:------|-------------------:|\n|Steve  |R     |                   4|Abena  |                   3|\n|Emma   |Excel |                   3|Yuika  |                   5|\n|Arti   |Excel |                   7|Yuika  |                   5|\n\n\n\n\nWe could do something similar, again using the name column, to add in some dis-similar data from another source:\n\n\n\n\n\n```{.r .cell-code}\nz <- tibble(\n  name = c(\"Abena\", \"Yuika\", \"Arti\", \"Steve\", \"Emma\", \"Bruce\"),\n  score = c(90, 85, 80, 75, 70, 33)\n)\n\nx |>\n  left_join(z, by = \"name\") |>\n  knitr::kable()\n```\n\n\n\n|name  |tool  | training_sessions| score|\n|:-----|:-----|-----------------:|-----:|\n|Steve |R     |                 4|    75|\n|Emma  |Excel |                 3|    70|\n|Arti  |Excel |                 7|    80|\n\n\n\n\n\nThere are several ways of doing this from R. If you're not a dplyr fan, you could use base-R's `merge` to do a left join:\n\n\n\n\n\n```{.r .cell-code}\nmerge(x, y, by = \"name\") |>\n  knitr::kable()\n```\n\n\n\n|name |tool.x | training_sessions.x|tool.y   | training_sessions.y|\n|:----|:------|-------------------:|:--------|-------------------:|\n|Arti |Excel  |                   7|Power BI |                   3|\n\n\n\n\nYou should see that only the values from `y`'s score column that have a corresponding name in `x` get populated, and everything else gets filled with NAs. Here's a [nice introduction to the different kinds of join you can do in dplyr](https://lindsaydbrin.github.io/CREATE_R_Workshop/Lesson_-_dplyr_join.html).\n\nAgain, we can do something similar in PowerQuery - note that joins are called `Merges`\n\n![Select Merge Queries](images/clipboard-4096182636.png)\n\n![Pick data to merge, and columns to merge on](images/clipboard-2316589936.png)\n\n![You'll need to expand the values in the new column](images/clipboard-2513654082.png)\n\n![Resulting joined data](images/clipboard-3678634774.png)\n\n## Anti-join\n\nAn anti-join takes a dataset, and removes any matching values from the second dataset:\n\n![An anti-join](images/anti.png)\n\n\n\n\n\n```{.r .cell-code}\nx |>\n  anti_join(y, by = \"name\") |>\n  knitr::kable()\n```\n\n\n\n|name  |tool  | training_sessions|\n|:-----|:-----|-----------------:|\n|Steve |R     |                 4|\n|Emma  |Excel |                 3|\n\n\n\n\n## Final thoughts\n\n-   some nice discussion about using `dplyr::semi_join` to find similar rows of data without actually binding columns\n-   using the [pointblank](https://rstudio.github.io/pointblank/) package for data validation\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}