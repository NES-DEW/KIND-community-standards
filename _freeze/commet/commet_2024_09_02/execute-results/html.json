{
  "hash": "cbf577f4e0cb32af1ff1e204e028190f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joins 1: introduction\"\ndate: 2024-09-02\ncategories: [Joins, beginner, Excel, R, Power Query]\nexecute: \n  output: asis\n  echo: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n## How to think about joins?\n\nA join is a way of merging two datasets. Let's demonstrate with some simple data:\n\n\n\n```{.r .cell-code}\nlibrary(tibble)\nlibrary(dplyr)\n```\n\n\n```{.r .cell-code}\nx <- tibble(\n  name = c(\"Steve\", \"Emma\", \"Arti\"),\n  tool = c(\"R\", \"Excel\", \"Excel\"),\n  training_sessions = c(4,3,7)\n)\n```\n\n\n|name  |tool  | training_sessions|\n|:-----|:-----|-----------------:|\n|Steve |R     |                 4|\n|Emma  |Excel |                 3|\n|Arti  |Excel |                 7|\n\n\n```{.r .cell-code}\ny <- tibble(\n  name = c(\"Abena\", \"Yuika\", \"Arti\"),\n  tool = c(\"R\", \"Excel\", \"Power BI\"),\n  training_sessions = c(3,5,3)\n)\n```\n\n\n|name  |tool  | training_sessions|\n|:-----|:-----|-----------------:|\n|Steve |R     |                 4|\n|Emma  |Excel |                 3|\n|Arti  |Excel |                 7|\n\n\n## Binding\n\nThe simplest join we could do is to bind the rows from one set onto another:\n\n\n\n```{.r .cell-code}\nx |>\n  bind_rows(y) |>\n  knitr::kable()\n```\n\n\n\n|name  |tool     | training_sessions|\n|:-----|:--------|-----------------:|\n|Steve |R        |                 4|\n|Emma  |Excel    |                 3|\n|Arti  |Excel    |                 7|\n|Abena |R        |                 3|\n|Yuika |Excel    |                 5|\n|Arti  |Power BI |                 3|\n\nThat just brings all the rows from `y` onto the end of `x`. We could also have just bound the columns together:\n\n\n\n```{.r .cell-code}\nx |>\n  bind_cols(y) |>\n  knitr::kable()\n```\n\n\n\n|name...1 |tool...2 | training_sessions...3|name...4 |tool...5 | training_sessions...6|\n|:--------|:--------|---------------------:|:--------|:--------|---------------------:|\n|Steve    |R        |                     4|Abena    |R        |                     3|\n|Emma     |Excel    |                     3|Yuika    |Excel    |                     5|\n|Arti     |Excel    |                     7|Arti     |Power BI |                     3|\n\n\nDoing this in R, we end up with something quite messy: we've gained some new columns (with odd names), and lots of blank values. The reason for this is that the Arti's has a row in each dataset. Anyone without corresponding rows gets filling in with blanks.\n\n## Joins proper\n\nUnlike binding, though, in a join we usually want to only include some of our values. So let's now left-join `y` onto x:\n\n\n\n```{.r .cell-code}\nx |>\n  left_join(y, by = \"name\") |>\n  knitr::kable()\n```\n\n\n\n|name  |tool.x | training_sessions.x|tool.y   | training_sessions.y|\n|:-----|:------|-------------------:|:--------|-------------------:|\n|Steve |R      |                   4|NA       |                  NA|\n|Emma  |Excel  |                   3|NA       |                  NA|\n|Arti  |Excel  |                   7|Power BI |                   3|\n\n\nYou should see that only the values from `y`'s score column that have a corresponding name in `x` get populated, and everything else gets filled with NAs. Here's a [nice introduction to the different kinds of join you can do in dplyr](https://lindsaydbrin.github.io/CREATE_R_Workshop/Lesson_-_dplyr_join.html).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}