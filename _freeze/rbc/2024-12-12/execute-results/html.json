{
  "hash": "9fc524ec76e3edb692dcba960bc56efc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R beginner's club 2024-12-12\nexecute: \n  output: markdown\n  echo: true\n  freeze: auto\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages for this session\n\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n## Don't repeat yourself!\n\nA key coding principle: don't repeat yourself. This session is a light introduction to functionals, and related tools, that let you apply functions in an intelligent and concise way.\n\n## Lists again\n\nWe'll do rather a lot with lists in this session. Lists are a basic data structure in R. You can think of them as a collection of vectors. They have two distinctive properties. First, and unlike vectors, lists can contain several different types of data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\"clive\", 99:1, penguins[2,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"clive\"\n\n[[2]]\n [1] 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75\n[26] 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50\n[51] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25\n[76] 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n[[3]]\n# A tibble: 1 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.5          17.4               186        3800\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n\nAs that example shows, unlike tibbles, lists can be ragged, containing vectors of different lengths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_list <- list(dunn = \"clive\", \n                  ready_or_not = 99:1,\n                  pengs = penguins) # or with names\n```\n:::\n\n\n\nThere's lots to say about working with lists, but the most helpful reminder is about subsetting. This can trip people up, because you can either return a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_list$dunn  # returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"clive\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntest_list[[\"dunn\"]] # equivalent\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"clive\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntest_list[[1]] # subsetting by extracting a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"clive\"\n```\n\n\n:::\n:::\n\n\n\nOr you can return a smaller list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_list[1] # subsetting to return a mini-list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dunn\n[1] \"clive\"\n```\n\n\n:::\n:::\n\n\n\nThe important thing is to be sure about exactly which of those you're planning to do, and then check to make sure that you're actually getting what you'd planned. And this minor pain-point is entirely worthwhile, because lists are so flexible. If in doubt, use a list.\n\n# Functions\n\nR is largely functional. We do things by writing expressions that pass objects to functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(LETTERS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26\n```\n\n\n:::\n\n```{.r .cell-code}\nnums <- c(5:1, 9:2, 8:22)\nsum(nums)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 284\n```\n\n\n:::\n:::\n\n\n\nUsually that's simple. But imagine that you want to apply the same function to a group of objects:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(nums[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(nums[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(nums[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nThis starts to contradict the advice about not repeating yourself. We're essentially writing the same function call several times. Happily though, R offers several alternative ways of constructing expressions that pass objects to functions. This session will look at two groups of alternative approaches.\n\n## do.call\n\nThe first is `do.call`. From the man page: \n\n> 'do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.'\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# do.call(what = function, args = arguments to that function)\ndo.call(\"complex\", list(imaginary = 1:3)) # handy if you ever need to calculate a Mandelbrot set in a hurry\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0+1i 0+2i 0+3i\n```\n\n\n:::\n\n```{.r .cell-code}\ndo.call(\"sum\", list(nums)) # the same as just summing everything\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 284\n```\n\n\n:::\n:::\n\n\n\nFor now, that probably doesn't seem very exciting. But being able to build function calls in a different way, where their arguments are held in a list, can be extremely useful. `do.call` is also especially useful when you want to use operators as if they were standard functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_nums <- list(c(1:5), c(5:1))\ndo.call(\"*\", big_nums)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 8 9 8 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# or for collecting several arguments, and then evaluating them\narg <- list(1:10, na.rm = T)\ndo.call(sum, args = arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n\n```{.r .cell-code}\ndo.call(mean, args = arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\n\n## lapply\n\n`lapply` is a base-R function that applies a function to an object, and collects the output in a list. Imagine we've got a list containing a couple of numeric vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- list(c(1,2), c(3,4))\n```\n:::\n\n\n\nWe can use `lapply` to sum each vector, and return a new list of those sums:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(nums, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\n[1] 7\n```\n\n\n:::\n:::\n\n\n\nSome other simple examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(penguins, class) # gives you back a list of the same length\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"factor\"\n\n$island\n[1] \"factor\"\n\n$bill_length_mm\n[1] \"numeric\"\n\n$bill_depth_mm\n[1] \"numeric\"\n\n$flipper_length_mm\n[1] \"integer\"\n\n$body_mass_g\n[1] \"integer\"\n\n$sex\n[1] \"factor\"\n\n$year\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(penguins, mean, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] NA\n\n$island\n[1] NA\n\n$bill_length_mm\n[1] 43.92193\n\n$bill_depth_mm\n[1] 17.15117\n\n$flipper_length_mm\n[1] 200.9152\n\n$body_mass_g\n[1] 4201.754\n\n$sex\n[1] NA\n\n$year\n[1] 2008.029\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(penguins, \"class\") # horrible but possible\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"factor\"\n\n$island\n[1] \"factor\"\n\n$bill_length_mm\n[1] \"numeric\"\n\n$bill_depth_mm\n[1] \"numeric\"\n\n$flipper_length_mm\n[1] \"integer\"\n\n$body_mass_g\n[1] \"integer\"\n\n$sex\n[1] \"factor\"\n\n$year\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n`lapply` and `do.call` play very nicely together:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(lapply(penguins, class)) # nonsense\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"factor\"\n\n$island\n[1] \"factor\"\n\n$bill_length_mm\n[1] \"numeric\"\n\n$bill_depth_mm\n[1] \"numeric\"\n\n$flipper_length_mm\n[1] \"integer\"\n\n$body_mass_g\n[1] \"integer\"\n\n$sex\n[1] \"factor\"\n\n$year\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndo.call(c, lapply(penguins, class))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n         \"factor\"          \"factor\"         \"numeric\"         \"numeric\" \nflipper_length_mm       body_mass_g               sex              year \n        \"integer\"         \"integer\"          \"factor\"         \"integer\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndo.call(tibble, lapply(penguins, class))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>   <chr>  <chr>          <chr>         <chr>             <chr>      \n1 factor  factor numeric        numeric       integer           integer    \n# ℹ 2 more variables: sex <chr>, year <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins[do.call(c, lapply(penguins, is.numeric))] # wild\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 5\n   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n            <dbl>         <dbl>             <int>       <int> <int>\n 1           39.1          18.7               181        3750  2007\n 2           39.5          17.4               186        3800  2007\n 3           40.3          18                 195        3250  2007\n 4           NA            NA                  NA          NA  2007\n 5           36.7          19.3               193        3450  2007\n 6           39.3          20.6               190        3650  2007\n 7           38.9          17.8               181        3625  2007\n 8           39.2          19.6               195        4675  2007\n 9           34.1          18.1               193        3475  2007\n10           42            20.2               190        4250  2007\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\nThere are other kinds of `*apply` functions in base R, like `tapply`, `sapply` and so on. My advice is to ignore them completely as they're very quirky and hard to use consistently. The [purrr](https://purrr.tidyverse.org/) package is a much stronger option:\n\n## purrr\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(penguins, class) # basically lapply\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"factor\"\n\n$island\n[1] \"factor\"\n\n$bill_length_mm\n[1] \"numeric\"\n\n$bill_depth_mm\n[1] \"numeric\"\n\n$flipper_length_mm\n[1] \"integer\"\n\n$body_mass_g\n[1] \"integer\"\n\n$sex\n[1] \"factor\"\n\n$year\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmap_vec(penguins, class) # but with lovely programmer-pleasing sweeteners\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species            island    bill_length_mm     bill_depth_mm \n         \"factor\"          \"factor\"         \"numeric\"         \"numeric\" \nflipper_length_mm       body_mass_g               sex              year \n        \"integer\"         \"integer\"          \"factor\"         \"integer\" \n```\n\n\n:::\n:::\n\n\n\n`map` gives you a standard way of applying a function over an object, and then being able to control how your output is returned. Say you've got some odd non-vectorised function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfb <- function(n){\n  out <- \"\"\n  if (n %% 3 == 0) out <- \"fizz\"\n  if (n %% 5 == 0) out <- paste0(out, \"buzz\")\n  if(nchar(out) == 0) out <- as.character(n)\n  out\n}\n```\n:::\n\n\n\nThat works fine on single values, but chokes when supplied with several values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfb(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfb(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"fizz\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(fb(8:9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in if (n%%3 == 0) out <- \"fizz\" : the condition has length > 1\n```\n\n\n:::\n:::\n\n\n\nWe could `lapply` this, or `map` it, to produce a list of output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(8:9, fb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\"\n\n[[2]]\n[1] \"fizz\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(8:9, fb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\"\n\n[[2]]\n[1] \"fizz\"\n```\n\n\n:::\n:::\n\n\n\nBut the advantage of `map` is that we can trivially change the output by tweaking the function name. Rather than `map` we could return a character vector with `map_chr`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(1:20, fb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"fizz\"     \"4\"        \"buzz\"     \"fizz\"    \n [7] \"7\"        \"8\"        \"fizz\"     \"buzz\"     \"11\"       \"fizz\"    \n[13] \"13\"       \"14\"       \"fizzbuzz\" \"16\"       \"17\"       \"fizz\"    \n[19] \"19\"       \"buzz\"    \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}