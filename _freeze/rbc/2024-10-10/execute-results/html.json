{
  "hash": "9d6ca221849c44f901dc66cd3a0af6c0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R beginner's club 2024-09-12\nexecute: \n  output: markdown\n  echo: true\n  freeze: auto\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages for this session\n\nlibrary(dplyr)\nlibrary(forcats)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(openxlsx)\nlibrary(readxl)\n```\n:::\n\n\n\n\n## Factors are confusing!\n\nFactors are confusing, but also *factors are powerful*. The reason they're powerful is they give you proper tools for managing categorical data, and especially caregorical data that has a fixed order. Let's set up an example to play with. Take an ordinary vector of character strings:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_s <- c(\"Tweak\", \"Barnacles\", \"Dashi\", \"Kwazii\")\n```\n:::\n\n\n\n\nWe can convert that into a factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_f <- factor(oct_s)\n```\n:::\n\n\n\n\nTo see what difference that's made, let's call up both the string vector and the factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_s\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Tweak\"     \"Barnacles\" \"Dashi\"     \"Kwazii\"   \n```\n\n\n:::\n\n```{.r .cell-code}\noct_f\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Tweak     Barnacles Dashi     Kwazii   \nLevels: Barnacles Dashi Kwazii Tweak\n```\n\n\n:::\n:::\n\n\n\n\nSo we've gained a new part in the factor: levels. You can think of levels as the possible values that our factor might contain. By default, when you create a factor from some strings, it takes the unique values, puts them in alphabetical order, and uses those as the levels:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(oct_f) # alphabetical\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Barnacles\" \"Dashi\"     \"Kwazii\"    \"Tweak\"    \n```\n\n\n:::\n:::\n\n\n\n\nIn fact, if you look carefully at the structure of a factor, you'll see something surprising:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(oct_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nSo factors are basically vectors of integers, with each integer standing in for one of the possible levels. This makes factors more efficient than ordinary strings:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# guess who's been reading Advanced R\nlobstr::obj_size(sample(oct_s, 100000, T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n800.28 kB\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_size(sample(oct_f, 100000, T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n400.70 kB\n```\n\n\n:::\n:::\n\n\n\n\nIt also means that we get to use some of the number-oriented tools to work with categorical data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sample(oct_s, 100000, T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n   100000 character character \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(sample(oct_f, 100000, T)) # nice frequency table with no effort\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBarnacles     Dashi    Kwazii     Tweak \n    24854     24812     25414     24920 \n```\n\n\n:::\n:::\n\n\n\n\nThings get really interesting when we realise we can change the order of levels from the default alphabetical ordering:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_f_l <- factor(oct_s, levels = c(\"Dashi\", \"Tweak\", \"Barnacles\", \"Kwazii\"))\n\noct_f_l\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Tweak     Barnacles Dashi     Kwazii   \nLevels: Dashi Tweak Barnacles Kwazii\n```\n\n\n:::\n:::\n\n\n\n\nThat's very interesting, because the ordering of factors gets preserved in all kinds of places:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_f_l_tibble <- tibble(oct_f_l,\n                         score = c(7,5,9,4)) \n\noct_f_l_tibble |>\n  ggplot() +\n  geom_col(aes(x = oct_f_l, y = score, fill = oct_f_l)) \n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noct_f_l_tibble |>\n  group_by(oct_f_l) |>\n  summarise(score = score * 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  oct_f_l   score\n  <fct>     <dbl>\n1 Dashi       180\n2 Tweak       140\n3 Barnacles   100\n4 Kwazii       80\n```\n\n\n:::\n:::\n\n\n\n\nIf you want to get fancy with factors, the [forcats](https://forcats.tidyverse.org/) package has some great tools. Some quick examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_s |>\n  factor() |>\n  fct_inorder() |> # build a factor with levels in order of appearance\n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Tweak\"     \"Barnacles\" \"Dashi\"     \"Kwazii\"   \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noct_plot <- oct_f_l_tibble |>\n  ggplot(aes(y = score, fill = oct_f_l)) \n\noct_plot +\n  geom_col(aes(x = fct_reorder(oct_f_l, c(4,2,3,1)))) # re-order levels in place\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noct_plot +\n  geom_col(aes(x = fct_reorder(oct_f_l, -score))) # order levels by other values\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\n\n### example 1: forcing non-alphabetical ordering\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth_v <- month.name[1:4]\n\nmonth_f <- factor(month_v, levels = c(\"January\", \"February\", \"March\", \"April\"))\n\n# or fct_inorder(factor(month.name[1:4])) would get you there too\n\ntibble(month = month_f,\n       values = c(99,55,22,101)) |>\n  ggplot() +\n  geom_col(aes(x = month, y = values))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntibble(month = month_f,\n       values = c(99,55,22,101)) |>\n  ggplot() +\n  geom_col(aes(x = fct_reorder(month, -values), y = values))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n\n\n\n### example 2: dealing with numeric categories\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  ggplot() + \n  geom_point(aes(x = wt, y = hp, colour = gear)) # continuous presentation of categories\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmtcars |>\n  ggplot() + \n  geom_point(aes(x = wt, y = hp, colour = factor(gear)))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n:::\n\n\n\n\n## How do I filter based on dates?\n\nThere are a couple of tips here. First, make sure that you're working with dates from as early in the process as possible. Don't try and cheat with text strings:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  date = c(\"01/02/2024\", \"01/04/2024\", \"01/06/2024\"),\n  val = c(\"one\", \"two\", \"three\")\n) |>\n  mutate(date = dmy(date)) \n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  date       val  \n  <date>     <chr>\n1 2024-02-01 one  \n2 2024-04-01 two  \n3 2024-06-01 three\n```\n\n\n:::\n:::\n\n\n\n\nThe second big bit of advice is to pick an approach to dates, and stick with it for everything. I like [lubridate](https://lubridate.tidyverse.org/), but you might prefer doing dates in [base R](https://www.r-bloggers.com/2019/04/the-ultimate-opinionated-guide-to-base-r-date-format-functions/), or [data.table](https://rdrr.io/cran/data.table/man/IDateTime.html), or something else. Whichever system you prefer, stick to one - it'll save masses of pain in the long-run.\n\nI like lubridate for this sort of work, because (to my mind) it has the easiest set of parsing functions to make dates from values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nydm(\"2021-28-4\") # including some horrible formats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2021-04-28\"\n```\n\n\n:::\n\n```{.r .cell-code}\nym(\"199907\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-07-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\nym(\"199907\") + days(11) # with additional setting\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-07-12\"\n```\n\n\n:::\n\n```{.r .cell-code}\nceiling_date(ym(\"199907\"), \"months\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1999-08-01\"\n```\n\n\n:::\n:::\n\n\n\n\nYou should be able to `dplyr::filter` your data in a few ways:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |>\n  filter(date == \"2024-04-01\") # assuming you remember how R dates are formatted\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  date       val  \n  <date>     <chr>\n1 2024-04-01 two  \n```\n\n\n:::\n\n```{.r .cell-code}\ndat |>\n  filter(date == ymd(\"2024-04-01\")) # probably safer to convert the string to a date\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  date       val  \n  <date>     <chr>\n1 2024-04-01 two  \n```\n\n\n:::\n\n```{.r .cell-code}\ndat |>\n  filter(date >= ymd(\"2022-04-01\")) # inequality filtering\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  date       val  \n  <date>     <chr>\n1 2024-02-01 one  \n2 2024-04-01 two  \n3 2024-06-01 three\n```\n\n\n:::\n\n```{.r .cell-code}\ndat |>\n  filter(date >= ymd(\"2022-04-01\") + years(2)) # filtering with offset\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  date       val  \n  <date>     <chr>\n1 2024-04-01 two  \n2 2024-06-01 three\n```\n\n\n:::\n\n```{.r .cell-code}\ndat |>\n  filter(date %within% interval(\"2024-03-01\", \"2024-05-01\")) # %within% is basically %in% for dates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  date       val  \n  <date>     <chr>\n1 2024-04-01 two  \n```\n\n\n:::\n:::\n\n\n\n\n## How can I read specific sheets out of an Excel file?\n\nIf you're using readxl, there's a nice `sheet = ` argument to allow you to read data directly from one sheet:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn <- \"data/s01_data.xlsx\"\n\nreadxl::read_xlsx(fn, sheet = \"occupancy_sh\") |>\n  slice(1:4) |>\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|date       |WardName | OccupiedBeds| BedComp| ClosedBed|\n|:----------|:--------|------------:|-------:|---------:|\n|2022-11-02 |A        |           16|      20|         2|\n|2022-11-02 |B        |           20|      20|         0|\n|2022-11-02 |C        |           21|      22|         1|\n|2022-11-02 |D        |           25|      30|         2|\n\n\n:::\n:::\n\n\n\n\nYou can also pull out all the sheet names from a workbook:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexcel_sheets(fn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"occupancy_sh\" \"wards_sh\"    \n```\n\n\n:::\n:::\n\n\n\n\nIf you want to be fancy, you can iterate through the sheets:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(excel_sheets(fn), \n       read_excel,\n       path = fn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tibble: 1,500 × 5\n   date                WardName OccupiedBeds BedComp ClosedBed\n   <dttm>              <chr>           <dbl>   <dbl>     <dbl>\n 1 2022-11-02 00:00:00 A                  16      20         2\n 2 2022-11-02 00:00:00 B                  20      20         0\n 3 2022-11-02 00:00:00 C                  21      22         1\n 4 2022-11-02 00:00:00 D                  25      30         2\n 5 2022-11-02 00:00:00 E                  15      22         3\n 6 2022-11-03 00:00:00 A                  14      20         0\n 7 2022-11-03 00:00:00 B                  19      20         3\n 8 2022-11-03 00:00:00 C                  18      22         0\n 9 2022-11-03 00:00:00 D                  26      30         0\n10 2022-11-03 00:00:00 E                  13      22         0\n# ℹ 1,490 more rows\n\n[[2]]\n# A tibble: 5 × 3\n  WardName LocationName HSCP  \n  <chr>    <chr>        <chr> \n1 A        Hosp1        HSCP_1\n2 B        Hosp2        HSCP_2\n3 C        Hosp1        HSCP_1\n4 D        Hosp1        HSCP_1\n5 E        Hosp3        HSCP_1\n```\n\n\n:::\n:::\n\n\n\n\n## How can I swap colour palettes in ggplot\n\nThere are several different strategies that might be useful for tweaking ggplot colours. Let's set up a quick factors plot based on months:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_plot <- tibble(month = month_f,\n       values = c(99,55,22,101)) |>\n  ggplot() +\n  geom_col(aes(x = fct_reorder(month, -values), \n               y = values, \n               fill = fct_reorder(month, -values))) \n\nfactors_plot\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n\nYou can manually assign colours. R recognises about 600 different ordinary colour names:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_plot + \n  scale_fill_manual(values = c(\"red\", \"green\", \"black\", \"grey\"))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\nOr, with more precision, you can specify [hex values](https://www.w3schools.com/colors/colors_hexadecimal.asp):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_plot + \n  scale_fill_manual(values = c(\"#115599\", \"#aa1199\", \"black\", \"#ff6600\"))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\nThis is fine for simple plots, or when you have e.g. specific colour palettes to use (like you might find in an organisational style manual). But for one-off or more sophisticated uses, it's definitely worth exploring [ColorBrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) - especially because this has great support for producing accessible colour palettes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_plot + \n  scale_fill_brewer(palette = \"RdBu\")\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n\nFinally, a nice weird trick: you can reverse the default order that ggplot creates fill colours using `scales::hue_pal`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_plot +\n  scale_fill_manual(values = scales::hue_pal(direction = 1)(4))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n```{.r .cell-code}\nfactors_plot +\n  scale_fill_manual(values = scales::hue_pal(direction = -1)(4))\n```\n\n::: {.cell-output-display}\n![](2024-10-10_files/figure-html/unnamed-chunk-27-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "2024-10-10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}